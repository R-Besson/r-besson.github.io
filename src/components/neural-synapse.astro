<canvas id="bg-canvas" class="fixed top-0 left-0 -z-10 w-full h-full"></canvas>

<script>
	import * as THREE from "three";

	import { EffectComposer } from "three/examples/jsm/postprocessing/EffectComposer.js";
	import { RenderPass } from "three/examples/jsm/postprocessing/RenderPass.js";
	import { UnrealBloomPass } from "three/examples/jsm/postprocessing/UnrealBloomPass.js";
	import { ShaderPass } from "three/examples/jsm/postprocessing/ShaderPass.js";
	import { gsap } from "gsap";

	const vertexShader = `
        uniform float u_time;
        uniform float u_intensity;
        uniform vec2 u_mouse;
        uniform vec2 u_click_shockwave;


        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
        vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

        float snoise(vec3 v) {
            const vec2 C = vec2(1.0/6.0, 1.0/3.0);
            const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i = floor(v + dot(v, C.yyy));
            vec3 x0 = v - i + dot(i, C.xxx);
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy;
            vec3 x3 = x0 - D.yyy;
            i = mod289(i);
            vec4 p = permute( permute( permute( i.z + vec4(0.0, i1.z, i2.z, 1.0 )) + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3 ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_);
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
            p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3) ) );
        }
        
        varying float v_displacement;
        varying vec3 v_normal;

        void main() {
            v_normal = normal;
            vec3 pos = position;
            float noise_freq = 1.2;
            float noise_amp = 0.2;


            vec3 noise_pos = vec3(pos.x * noise_freq + u_time * 0.2, pos.y * noise_freq + u_time * 0.2, pos.z * noise_freq);
            pos += normal * snoise(noise_pos) * noise_amp;


            float mouse_dist = distance(vec2(pos.x, pos.y), u_mouse * 2.0);
            float mouse_influence = max(0.0, 1.0 - mouse_dist * 2.0) * u_intensity;
            pos += normal * mouse_influence * 0.4;
            

            float shockwave_radius = u_click_shockwave.x * 2.5; 
            float shockwave_thickness = 0.4;
            float dist_from_center = length(pos);
            float shockwave_falloff = 1.0 - smoothstep(shockwave_radius - shockwave_thickness, shockwave_radius, dist_from_center);
            float shockwave_crest = smoothstep(shockwave_radius - shockwave_thickness - 0.1, shockwave_radius - shockwave_thickness, dist_from_center);
            float shockwave = shockwave_falloff * shockwave_crest;
            pos += normal * shockwave * u_click_shockwave.y * 0.5;

            v_displacement = noise_amp * snoise(noise_pos) + mouse_influence * 0.4 + shockwave * u_click_shockwave.y * 0.5;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
        }
    `;

	const fragmentShader = `
        uniform float u_time;
        varying float v_displacement;
        varying vec3 v_normal;
        
        void main() {
            float intensity = pow(0.7 - dot(v_normal, vec3(0.0, 0.0, 1.0)), 2.0);
            vec3 base_color = vec3(0.1, 0.3, 0.8);
            vec3 glow_color = vec3(0.4, 0.8, 1.0);
            vec3 final_color = mix(base_color, glow_color, v_displacement * 2.0);
            gl_FragColor = vec4(final_color + intensity * 0.2, 1.0);
        }
    `;

	const chromaticAberrationShader = {
		uniforms: { tDiffuse: { value: null }, u_amount: { value: 0.003 } },
		vertexShader: `varying vec2 v_uv; void main() { v_uv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
		fragmentShader: `
			uniform sampler2D tDiffuse; uniform float u_amount; varying vec2 v_uv;
			void main() {
				vec2 center = vec2(0.5, 0.5); vec2 offset = v_uv - center; vec4 color;
				color.r = texture2D(tDiffuse, v_uv - offset * u_amount).r;
				color.g = texture2D(tDiffuse, v_uv).g;
				color.b = texture2D(tDiffuse, v_uv + offset * u_amount).b;
				color.a = texture2D(tDiffuse, v_uv).a;
				gl_FragColor = color;
			}`,
	};
	const finalPassShader = {
		uniforms: {
			tDiffuse: { value: null },
		},
		vertexShader: `
            varying vec2 v_uv;
            void main() {
                v_uv = uv;
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `,
		fragmentShader: `
            uniform sampler2D tDiffuse;
            varying vec2 v_uv;
            void main() {
                vec4 textureColor = texture2D(tDiffuse, v_uv);
                float alpha = length(textureColor.rgb);
                gl_FragColor = vec4(textureColor.rgb, alpha);
            }
        `,
	};

	class Sketch {
		constructor(options) {
			this.dom = options.dom;

			this.width = window.innerWidth;
			this.height = window.innerHeight;

			this.scene = new THREE.Scene();

			this.camera = new THREE.PerspectiveCamera(
				70,
				this.width / this.height,
				0.1,
				1000,
			);

			this.camera.position.set(0, 0, 5);

			this.renderer = new THREE.WebGLRenderer({
				canvas: this.dom,
				alpha: true,
				antialias: true,
			});
			this.renderer.setClearColor(0x000000, 0);
			this.renderer.setSize(this.width, this.height);
			this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

			this.mouse = new THREE.Vector2(0, 0);
			this.targetMouse = new THREE.Vector2(0, 0);
			this.mouseIntensity = { value: 0 };

			this.composer = new EffectComposer(this.renderer);
			this.renderPass = new RenderPass(this.scene, this.camera);
			this.composer.addPass(this.renderPass);
			this.unrealBloomPass = new UnrealBloomPass(
				new THREE.Vector2(this.width, this.height),
				0.9,
				0.2,
				0.1,
			);
			this.composer.addPass(this.unrealBloomPass);
			this.chromaticAberrationPass = new ShaderPass(
				chromaticAberrationShader,
			);
			this.composer.addPass(this.chromaticAberrationPass);
			const finalPass = new ShaderPass(finalPassShader);
			this.composer.addPass(finalPass);

			this.clock = new THREE.Clock();

			this.init();
		}

		init() {
			this.createLights();
			this.createCoreObject();
			this.createRings();
			this.addEventListeners();
			this.onWindowResize();
			this.animate();
		}

		createLights() {
			const ambientLight = new THREE.AmbientLight(0x4040ff, 0.5);
			this.scene.add(ambientLight);

			const pointLight1 = new THREE.PointLight(0x892cdc, 1.5, 15);
			pointLight1.position.set(4, 2, 4);
			this.scene.add(pointLight1);

			const pointLight2 = new THREE.PointLight(0x00aaff, 2, 15);
			pointLight2.position.set(-4, -2, 3);
			this.scene.add(pointLight2);
		}

		createCoreObject() {
			const geometry = new THREE.IcosahedronGeometry(1, 64);
			this.shaderMaterial = new THREE.ShaderMaterial({
				uniforms: {
					u_time: { value: 0 },
					u_intensity: { value: 0 },
					u_mouse: { value: new THREE.Vector2(0, 0) },
					u_click_shockwave: { value: new THREE.Vector2(0, 0) },
				},
				vertexShader: vertexShader,
				fragmentShader: fragmentShader,
			});
			this.core = new THREE.Mesh(geometry, this.shaderMaterial);

			this.mainGroup = new THREE.Group();
			this.mainGroup.add(this.core);

			this.mainGroup.scale.set(0.9, 0.9, 0.9);

			this.scene.add(this.mainGroup);

			this.camera.lookAt(this.mainGroup.position);
		}

		createRings() {
			this.rings = [];
			const ringCount = 5;

			for (let i = 0; i < ringCount; i++) {
				const radius = 1.4 + i * 0.25;
				const tube = 0.01 + i * 0.003;
				const geometry = new THREE.TorusGeometry(radius, tube, 16, 100);
				const material = new THREE.MeshPhysicalMaterial({
					color: 0x87ceeb,
					transmission: 1.0,
					roughness: 0.1,
					thickness: 0.1,
					ior: 1.8,
					transparent: true,
					opacity: 0.5,
				});

				const ring = new THREE.Mesh(geometry, material);
				ring.rotation.x = Math.random() * Math.PI;
				ring.rotation.y = Math.random() * Math.PI;
				ring.userData.initialRotation = ring.rotation.clone();

				this.mainGroup.add(ring);
				this.rings.push(ring);
			}
		}

		addEventListeners() {
			window.addEventListener("resize", this.onWindowResize.bind(this));
			window.addEventListener("mousemove", this.onMouseMove.bind(this));
			window.addEventListener("mousedown", this.onMouseDown.bind(this));
		}

		onWindowResize() {
			this.width = window.innerWidth;
			this.height = window.innerHeight;

			this.camera.aspect = this.width / this.height;
			this.camera.updateProjectionMatrix();

			this.renderer.setSize(this.width, this.height);
			this.composer.setSize(this.width, this.height);
			this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

			if (this.width / this.height > 1.5) {
				this.mainGroup.position.x = -2.8;
			} else {
				this.mainGroup.position.x = -2.2;
			}
		}

		onMouseMove(event) {
			this.targetMouse.x = (event.clientX / this.width) * 2 - 1;
			this.targetMouse.y = -(event.clientY / this.height) * 2 + 1;

			gsap.to(this.mouseIntensity, {
				value: 1.0,
				duration: 1.0,
				ease: "power2.out",
			});
		}

		onMouseDown() {
			const shockwave =
				this.shaderMaterial.uniforms.u_click_shockwave.value;
			gsap.fromTo(
				shockwave,
				{ x: 0.0, y: 1.0 },
				{
					x: 1.0,
					y: 0.0,
					duration: 1.5,
					ease: "expo.out",
				},
			);

			this.rings.forEach((ring, i) => {
				gsap.timeline()
					.to(ring.scale, {
						x: 1 + 0.1 * (i + 1) * 0.5,
						y: 1 + 0.1 * (i + 1) * 0.5,
						z: 1 + 0.1 * (i + 1) * 0.5,
						duration: 0.4,
						ease: "power2.out",
					})
					.to(ring.scale, {
						x: 1,
						y: 1,
						z: 1,
						duration: 1.0,
						ease: "elastic.out(1, 0.5)",
					});
				gsap.to(ring.material.color, {
					r: 1,
					g: 1,
					b: 1,
					duration: 0.2,
					yoyo: true,
					repeat: 1,
					ease: "power2.inOut",
				});
			});
		}

		animate() {
			requestAnimationFrame(this.animate.bind(this));
			const elapsedTime = this.clock.getElapsedTime();

			this.mouse.lerp(this.targetMouse, 0.05);

			this.shaderMaterial.uniforms.u_time.value = elapsedTime;
			this.shaderMaterial.uniforms.u_mouse.value.copy(this.mouse);
			this.shaderMaterial.uniforms.u_intensity.value =
				this.mouseIntensity.value;

			if (this.core) {
				this.core.rotation.y = elapsedTime * 0.1;
				this.core.rotation.x = elapsedTime * 0.05;
			}

			this.rings.forEach((ring) => {
				const targetRotationX =
					ring.userData.initialRotation.x - this.mouse.y * 0.2;
				const targetRotationY =
					ring.userData.initialRotation.y + this.mouse.x * 0.2;
				ring.rotation.x += (targetRotationX - ring.rotation.x) * 0.05;
				ring.rotation.y += (targetRotationY - ring.rotation.y) * 0.05;
			});

			this.composer.render();
		}
	}

	if (document.readyState === "loading") {
		document.addEventListener("DOMContentLoaded", () => {
			new Sketch({ dom: document.getElementById("bg-canvas") });
		});
	} else {
		new Sketch({ dom: document.getElementById("bg-canvas") });
	}
</script>
